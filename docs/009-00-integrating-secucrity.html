<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-06-27T16:25:10.733668"><title>Chapitre 9 : Tester Sous Haute Surveillance : Int&eacute;grer Spring Security (L'essentiel) | Java Spring Test</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction-le-badge-d-acc-s-de-l-agent-secret","level":0,"title":"Introduction : Le badge d\u0027accès de l\u0027agent secret","anchor":"#introduction-le-badge-d-acc-s-de-l-agent-secret"},{"id":"le-d-fi-spring-security-et-les-tests","level":0,"title":"Le Défi : Spring Security et les Tests","anchor":"#le-d-fi-spring-security-et-les-tests"},{"id":"withmockuser-votre-faux-badge-universel","level":0,"title":"@WithMockUser : Votre Faux Badge Universel","anchor":"#withmockuser-votre-faux-badge-universel"},{"id":"mettre-en-pratique-tester-un-contr-leur-s-curis","level":0,"title":"Mettre en Pratique : Tester un Contrôleur Sécurisé","anchor":"#mettre-en-pratique-tester-un-contr-leur-s-curis"},{"id":"exercice-12-prot-ger-un-endpoint-de-suppression","level":0,"title":"Exercice 12 : Protéger un endpoint de suppression","anchor":"#exercice-12-prot-ger-un-endpoint-de-suppression"},{"id":"correction-exercice-12","level":0,"title":"Correction exercice 12","anchor":"#correction-exercice-12"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion-de-la-partie","level":0,"title":"Conclusion de la partie","anchor":"#conclusion-de-la-partie"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Chapitre 9 : Tester Sous Haute Surveillance : Int&eacute;grer Spring Security (L'essentiel) | Java Spring Test"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Java Spring Test Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/009-00-integrating-secucrity.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Chapitre 9 : Tester Sous Haute Surveillance : Int&eacute;grer Spring Security (L'essentiel) | Java Spring Test"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/009-00-integrating-secucrity.html#webpage",
    "url": "writerside-documentation/009-00-integrating-secucrity.html",
    "name": "Chapitre 9 : Tester Sous Haute Surveillance : Int&eacute;grer Spring Security (L'essentiel) | Java Spring Test",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Java Spring Test Help"
}</script><!-- End Schema.org --></head><body data-id="009-00-integrating-secucrity" data-main-title="Chapitre 9 : Tester Sous Haute Surveillance : Intégrer Spring Security (L'essentiel)" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Java Spring Test  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="009-00-integrating-secucrity" id="009-00-integrating-secucrity.md">Chapitre 9 : Tester Sous Haute Surveillance : Intégrer Spring Security (L'essentiel)</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="z3l84kq_12">&Agrave; la fin de cette partie, vous serez en mesure de :</p><ul class="list _bullet" id="z3l84kq_13"><li class="list__item" id="z3l84kq_14"><p id="z3l84kq_19"><span class="control" id="z3l84kq_20">Comprendre</span> les d&eacute;fis pos&eacute;s par Spring Security lors des tests d'endpoints.</p></li><li class="list__item" id="z3l84kq_15"><p id="z3l84kq_21"><span class="control" id="z3l84kq_22">Utiliser</span> l'annotation <code class="code" id="z3l84kq_23">@WithMockUser</code> pour simuler un utilisateur authentifi&eacute; de mani&egrave;re simple.</p></li><li class="list__item" id="z3l84kq_16"><p id="z3l84kq_24"><span class="control" id="z3l84kq_25">Tester</span> des r&egrave;gles d'autorisation bas&eacute;es sur les r&ocirc;les (ex: <code class="code" id="z3l84kq_26">hasRole('ADMIN')</code>).</p></li><li class="list__item" id="z3l84kq_17"><p id="z3l84kq_27"><span class="control" id="z3l84kq_28">Simuler</span> une absence d'authentification pour tester les acc&egrave;s non autoris&eacute;s.</p></li><li class="list__item" id="z3l84kq_18"><p id="z3l84kq_29"><span class="control" id="z3l84kq_30">Int&eacute;grer</span> les annotations de test de s&eacute;curit&eacute; dans un test <code class="code" id="z3l84kq_31">@WebMvcTest</code>.</p></li></ul></section><section class="chapter"><h2 id="introduction-le-badge-d-acc-s-de-l-agent-secret" data-toc="introduction-le-badge-d-acc-s-de-l-agent-secret">Introduction : Le badge d'acc&egrave;s de l'agent secret</h2><p id="z3l84kq_32">Imaginez que votre API REST est un b&acirc;timent gouvernemental hautement s&eacute;curis&eacute;. Jusqu'&agrave; pr&eacute;sent, pour nos tests, nous avons fait comme si les portes &eacute;taient grandes ouvertes. Nous pouvions entrer et sortir &agrave; notre guise pour v&eacute;rifier que les bureaux (<code class="code" id="z3l84kq_35">endpoints</code>) fonctionnaient.</p><p id="z3l84kq_33">Mais maintenant, le syst&egrave;me de s&eacute;curit&eacute; (<code class="code" id="z3l84kq_36">Spring Security</code>) est activ&eacute;. Si vous essayez d'acc&eacute;der &agrave; un bureau sans le bon badge, l'acc&egrave;s vous est refus&eacute;. Un simple <code class="code" id="z3l84kq_37">GET /api/admin/reports</code> se solde par un <code class="code" id="z3l84kq_38">401 Unauthorized</code> ou un <code class="code" id="z3l84kq_39">403 Forbidden</code>. Comment tester nos bureaux si nous ne pouvons m&ecirc;me pas passer la porte d'entr&eacute;e ?</p><p id="z3l84kq_34">C'est l&agrave; qu'intervient le module de test de Spring Security. Il nous fournit une s&eacute;rie de &quot;faux badges&quot; (<code class="code" id="z3l84kq_40">@WithMockUser</code>) que nous pouvons pr&eacute;senter lors de nos tests. Ces badges nous permettent de dire au syst&egrave;me de s&eacute;curit&eacute; : &quot;Pour ce test-ci, fais comme si j'&eacute;tais l'utilisateur 'alex' avec le r&ocirc;le 'ADMIN'&quot;. Cela nous permet de tester nos endpoints dans des conditions de s&eacute;curit&eacute; r&eacute;alistes, sans avoir &agrave; simuler tout le processus complexe d'authentification (login/mot de passe).</p></section><section class="chapter"><h2 id="le-d-fi-spring-security-et-les-tests" data-toc="le-d-fi-spring-security-et-les-tests">Le D&eacute;fi : Spring Security et les Tests</h2><p id="z3l84kq_41">Lorsque vous ajoutez <code class="code" id="z3l84kq_44">spring-boot-starter-security</code> &agrave; votre projet, par d&eacute;faut, tous les endpoints de votre application deviennent prot&eacute;g&eacute;s. Un test qui fonctionnait parfaitement auparavant...</p><div class="code-block" data-lang="java">
mockMvc.perform(get(&quot;/api/users&quot;))
        .ndExpect(status().isOk());
</div><p id="z3l84kq_43">...commencera soudainement &agrave; &eacute;chouer avec un statut <code class="code" id="z3l84kq_45">401 Unauthorized</code> ou une redirection vers une page de login. C'est normal ! Spring Security fait son travail. Notre mission est d'apprendre &agrave; &quot;dire&quot; &agrave; nos tests avec quelle identit&eacute; ils doivent s'ex&eacute;cuter.</p></section><section class="chapter"><h2 id="withmockuser-votre-faux-badge-universel" data-toc="withmockuser-votre-faux-badge-universel"><code class="code" id="z3l84kq_50">@WithMockUser</code>: Votre Faux Badge Universel</h2><p id="z3l84kq_47">L'outil le plus simple et le plus courant pour tester la s&eacute;curit&eacute; est l'annotation <code class="code" id="z3l84kq_51">@WithMockUser</code>. Elle se place sur une m&eacute;thode de test (ou sur la classe pour s'appliquer &agrave; tous les tests) et cr&eacute;e un faux <code class="code" id="z3l84kq_52">Principal</code> dans le <code class="code" id="z3l84kq_53">SecurityContext</code> pour la dur&eacute;e du test.</p><section class="procedure-steps"><h3 id="z3l84kq_48" data-toc="z3l84kq_48">Scénarios de test avec @WithMockUser</h3><ul class="list _bullet"><li class="list__item" id="z3l84kq_54"><p><b id="z3l84kq_58">Simuler un utilisateur simple</b></p></li></ul><p id="z3l84kq_55">Le plus simple : simuler un utilisateur nomm&eacute; &quot;user&quot; avec un mot de passe &quot;password&quot; et un r&ocirc;le &quot;USER&quot;.</p><div class="code-block" data-lang="java">
    @Test
    @WithMockUser
    void testEndpointForAnyLoggedInUser() throws Exception {
        mockMvc.perform(get(&quot;/api/profile&quot;))
               .andExpect(status().isOk());
    }
    </div><div class="code-block" data-lang="none">&lt;step&gt;&lt;b&gt;Simuler un utilisateur avec un nom spécifique&lt;/b&gt;&lt;/step&gt;
&lt;code-block lang=&quot;java&quot;&gt;
@Test
@WithMockUser(username = &quot;alex.dev&quot;)
void testEndpointAsSpecificUser() throws Exception {
    // ...
}
&lt;/code-block&gt;

&lt;step&gt;&lt;b&gt;Simuler un utilisateur avec des rôles spécifiques&lt;/b&gt;&lt;/step&gt;
&lt;p&gt;C'est le cas le plus courant pour tester les autorisations.&lt;/p&gt;
&lt;code-block lang=&quot;java&quot;&gt;
@Test
@WithMockUser(roles = {&quot;ADMIN&quot;, &quot;AUDITOR&quot;})
void testEndpointForAdminAndAuditor() throws Exception {
    mockMvc.perform(get(&quot;/api/admin/reports&quot;))
           .andExpect(status().isOk());
}
&lt;/code-block&gt;

&lt;step&gt;&lt;b&gt;Simuler un utilisateur avec des autorisations (&quot;authorities&quot;)&lt;/b&gt;&lt;/step&gt;
&lt;p&gt;Si votre sécurité n'est pas basée sur des rôles (&lt;code&gt;ROLE_...&lt;/code&gt;) mais sur des autorisations plus fines.&lt;/p&gt;
&lt;code-block lang=&quot;java&quot;&gt;
@Test
@WithMockUser(authorities = &quot;book:read&quot;)
void testEndpointForUserWithReadPermission() throws Exception {
    // ...
}
&lt;/code-block&gt;
</div></section><aside class="prompt" data-type="warning" data-title="" id="z3l84kq_49"><p>**`roles` vs. `authorities`** Lorsque vous utilisez `roles = &quot;ADMIN&quot;`, Spring Security le traduit automatiquement en une autorit&eacute; `ROLE_ADMIN`. Si vous utilisez `authorities = &quot;ADMIN&quot;`, l'autorit&eacute; sera simplement `ADMIN`. Assurez-vous d'&ecirc;tre coh&eacute;rent avec la configuration de votre application (ex: `http.authorizeHttpRequests(auth -&gt; auth.requestMatchers(...).hasRole(&quot;ADMIN&quot;))`).</p></aside></section><section class="chapter"><h2 id="mettre-en-pratique-tester-un-contr-leur-s-curis" data-toc="mettre-en-pratique-tester-un-contr-leur-s-curis">Mettre en Pratique : Tester un Contr&ocirc;leur S&eacute;curis&eacute;</h2><p id="z3l84kq_59">Imaginons un <code class="code" id="z3l84kq_67">AdminController</code> qui ne devrait &ecirc;tre accessible qu'aux administrateurs.</p><p id="z3l84kq_60"><span class="control" id="z3l84kq_68">La configuration de s&eacute;curit&eacute; (simplifi&eacute;e) :</span></p><div class="code-block" data-lang="java">

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests(auth -&gt; auth
                        .requestMatchers(&quot;/api/admin/**&quot;).hasRole(&quot;ADMIN&quot;) // Seuls les admins
                        .anyRequest().authenticated() // Tout le reste nécessite une authentification
                )
                .httpBasic(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }
    // ... bean pour le UserDetailsService, PasswordEncoder etc.
}
</div><p id="z3l84kq_62"><span class="control" id="z3l84kq_69">Le contr&ocirc;leur &agrave; tester :</span></p><div class="code-block" data-lang="java">

@RestController
@RequestMapping(&quot;/api/admin&quot;)
public class AdminController {
    @GetMapping(&quot;/dashboard&quot;)
    public String getAdminDashboard() {
        return &quot;Welcome to the Admin Dashboard!&quot;;
    }
}
</div><p id="z3l84kq_64"><span class="control" id="z3l84kq_70">Le test avec <code class="code" id="z3l84kq_71">@WebMvcTest</code>:</span></p><div class="code-block" data-lang="java">
// src/test/java/fr/formation/spring/api/AdminControllerTest.java
package fr.formation.spring.api;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.context.annotation.Import;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import fr.formation.spring.config.SecurityConfig; // Important d'importer la config

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(AdminController.class)
@Import(SecurityConfig.class) // On doit importer notre config de sécurité
class AdminControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    @DisplayName(&quot;Devrait retourner 401 pour un utilisateur non authentifié&quot;)
    void getDashboard_shouldReturn401_forUnauthenticatedUser() throws Exception {
        mockMvc.perform(get(&quot;/api/admin/dashboard&quot;))
                .andExpect(status().isUnauthorized()); // ou 403 si CSRF est activé autrement
    }

    @Test
    @DisplayName(&quot;Devrait retourner 403 pour un utilisateur authentifié sans le bon rôle&quot;)
    @WithMockUser(username = &quot;user&quot;, roles = &quot;USER&quot;)
    void getDashboard_shouldReturn403_forUserWithWrongRole() throws Exception {
        mockMvc.perform(get(&quot;/api/admin/dashboard&quot;))
                .andExpect(status().isForbidden());
    }

    @Test
    @DisplayName(&quot;Devrait retourner 200 pour un utilisateur avec le rôle ADMIN&quot;)
    @WithMockUser(username = &quot;admin&quot;, roles = &quot;ADMIN&quot;)
    void getDashboard_shouldReturn200_forAdminUser() throws Exception {
        mockMvc.perform(get(&quot;/api/admin/dashboard&quot;))
                .andExpect(status().isOk());
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z3l84kq_66"><p>Dans un `@WebMvcTest`, la configuration de s&eacute;curit&eacute; n'est pas appliqu&eacute;e automatiquement. Vous devez l'importer explicitement avec `@Import(SecurityConfig.class)` pour que les r&egrave;gles (`hasRole`, etc.) soient prises en compte.</p></aside></section><section class="chapter"><h2 id="exercice-12-prot-ger-un-endpoint-de-suppression" data-toc="exercice-12-prot-ger-un-endpoint-de-suppression">Exercice 12 : Prot&eacute;ger un endpoint de suppression</h2><p id="z3l84kq_72">Vous avez un endpoint <code class="code" id="z3l84kq_75">DELETE /api/books/{id}</code> dans votre <code class="code" id="z3l84kq_76">BookController</code>. Vous devez vous assurer que seuls les utilisateurs ayant le r&ocirc;le <code class="code" id="z3l84kq_77">LIBRARIAN</code> (biblioth&eacute;caire) peuvent l'utiliser.</p><p id="z3l84kq_73"><span class="control" id="z3l84kq_78">Votre mission :</span></p><ol class="list _decimal" id="z3l84kq_74" type="1"><li class="list__item" id="z3l84kq_79"><p id="z3l84kq_83">Modifiez votre <code class="code" id="z3l84kq_84">SecurityConfig</code> (ou cr&eacute;ez-en une) pour ajouter la r&egrave;gle : <code class="code" id="z3l84kq_85">requestMatchers(HttpMethod.DELETE, &quot;/api/books/**&quot;).hasRole(&quot;LIBRARIAN&quot;)</code>.</p></li><li class="list__item" id="z3l84kq_80"><p id="z3l84kq_86">Cr&eacute;ez ou modifiez la classe de test <code class="code" id="z3l84kq_87">BookControllerTest</code>. Assurez-vous qu'elle est annot&eacute;e avec <code class="code" id="z3l84kq_88">@WebMvcTest</code> et qu'elle importe votre <code class="code" id="z3l84kq_89">SecurityConfig</code>.</p></li><li class="list__item" id="z3l84kq_81"><p id="z3l84kq_90">&Eacute;crivez trois tests pour l'endpoint <code class="code" id="z3l84kq_92">DELETE /api/books/1</code>:</p><ul class="list _bullet" id="z3l84kq_91"><li class="list__item" id="z3l84kq_93"><p id="z3l84kq_96">Un test pour un utilisateur non authentifi&eacute; (doit retourner <code class="code" id="z3l84kq_97">401 Unauthorized</code>).</p></li><li class="list__item" id="z3l84kq_94"><p id="z3l84kq_98">Un test avec <code class="code" id="z3l84kq_99">@WithMockUser(roles = &quot;READER&quot;)</code> (doit retourner <code class="code" id="z3l84kq_100">403 Forbidden</code>).</p></li><li class="list__item" id="z3l84kq_95"><p id="z3l84kq_101">Un test avec <code class="code" id="z3l84kq_102">@WithMockUser(roles = &quot;LIBRARIAN&quot;)</code> (doit retourner <code class="code" id="z3l84kq_103">204 No Content</code>, le statut de succ&egrave;s pour un DELETE sans corps de r&eacute;ponse).</p></li></ul></li><li class="list__item" id="z3l84kq_82"><p id="z3l84kq_104">N'oubliez pas de mocker le service sous-jacent avec <code class="code" id="z3l84kq_105">@MockBean</code>, m&ecirc;me si pour ces tests de s&eacute;curit&eacute;, il ne sera pas beaucoup sollicit&eacute;.</p></li></ol></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="correction-exercice-12" data-toc="correction-exercice-12">Correction exercice 12</h2></div><div class="collapse__content"><p id="z3l84kq_106"><span class="control" id="z3l84kq_112">1. La configuration de s&eacute;curit&eacute; (exemple) :</span></p><div class="code-block" data-lang="java">

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .authorizeHttpRequests(auth -&gt; auth
                        .requestMatchers(HttpMethod.DELETE, &quot;/api/books/**&quot;).hasRole(&quot;LIBRARIAN&quot;)
                        .anyRequest().permitAll() // On simplifie pour l'exercice
                )
                .csrf(AbstractHttpConfigurer::disable);
        return http.build();
    }
}
</div><p id="z3l84kq_108"><span class="control" id="z3l84kq_113">2. Le contr&ocirc;leur (simplifi&eacute;) :</span></p><div class="code-block" data-lang="java">

@RestController
@RequestMapping(&quot;/api/books&quot;)
public class BookController {
    private final BookService bookService;
    // ... constructeur ...

    @DeleteMapping(&quot;/{id}&quot;)
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteBook(@PathVariable Long id) {
        bookService.deleteById(id);
    }
}
</div><p id="z3l84kq_110"><span class="control" id="z3l84kq_114">3. La classe de test :</span></p><div class="code-block" data-lang="java">
// src/test/java/fr/formation/spring/api/BookControllerTest.java
package fr.formation.spring.api;

import fr.formation.spring.config.SecurityConfig;
import fr.formation.spring.service.BookService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.context.annotation.Import;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(BookController.class)
@Import(SecurityConfig.class)
class BookControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private BookService mockBookService;

    @Test
    void deleteBook_shouldReturn401_forUnauthenticated() throws Exception {
        mockMvc.perform(delete(&quot;/api/books/1&quot;))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @WithMockUser(roles = &quot;READER&quot;)
    void deleteBook_shouldReturn403_forUserWithWrongRole() throws Exception {
        mockMvc.perform(delete(&quot;/api/books/1&quot;))
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(roles = &quot;LIBRARIAN&quot;)
    void deleteBook_shouldReturn204_forLibrarian() throws Exception {
        mockMvc.perform(delete(&quot;/api/books/1&quot;))
                .andExpect(status().isNoContent());
    }
}

</div></div></div></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><ol class="list _decimal" id="z3l84kq_115" type="1"><li class="list__item" id="z3l84kq_117"><p id="z3l84kq_122">(Question ouverte) Pourquoi un test d'API REST qui fonctionnait bien &eacute;choue-t-il souvent avec un statut 401 apr&egrave;s l' ajout de Spring Security ?</p></li><li class="list__item" id="z3l84kq_118"><p id="z3l84kq_123">(QCM) Quelle annotation est la plus simple pour simuler un utilisateur &quot;admin&quot; avec le r&ocirc;le &quot;ADMIN&quot; pour un test ?</p><ul class="list _bullet" id="z3l84kq_124"><li class="list__item" id="z3l84kq_125"><p id="z3l84kq_129">a) <code class="code" id="z3l84kq_130">@WithAdminUser</code></p></li><li class="list__item" id="z3l84kq_126"><p id="z3l84kq_131">b) <code class="code" id="z3l84kq_132">@Test(user=&quot;admin&quot;, role=&quot;ADMIN&quot;)</code></p></li><li class="list__item" id="z3l84kq_127"><p id="z3l84kq_133">c) <code class="code" id="z3l84kq_134">@WithMockUser(username=&quot;admin&quot;, roles=&quot;ADMIN&quot;)</code></p></li><li class="list__item" id="z3l84kq_128"><p id="z3l84kq_135">d) <code class="code" id="z3l84kq_136">@MockBean(type=User.class, name=&quot;admin&quot;)</code></p></li></ul></li><li class="list__item" id="z3l84kq_119"><p id="z3l84kq_137">(Question ouverte) Quelle est la diff&eacute;rence de r&eacute;sultat attendu entre un utilisateur non authentifi&eacute; et un utilisateur authentifi&eacute; mais n'ayant pas les bons droits pour acc&eacute;der &agrave; une ressource ?</p></li><li class="list__item" id="z3l84kq_120"><p id="z3l84kq_138">(QCM) Dans un <code class="code" id="z3l84kq_140">@WebMvcTest</code>, pourquoi est-il souvent n&eacute;cessaire d'ajouter <code class="code" id="z3l84kq_141">@Import(SecurityConfig.class)</code>?</p><ul class="list _bullet" id="z3l84kq_139"><li class="list__item" id="z3l84kq_142"><p id="z3l84kq_146">a) Pour importer les utilisateurs de test.</p></li><li class="list__item" id="z3l84kq_143"><p id="z3l84kq_147">b) Pour charger les r&egrave;gles de s&eacute;curit&eacute; (<code class="code" id="z3l84kq_148">authorizeHttpRequests</code>, etc.) qui ne sont pas charg&eacute;es par d&eacute;faut dans ce type de test en tranche.</p></li><li class="list__item" id="z3l84kq_144"><p id="z3l84kq_149">c) Pour d&eacute;sactiver la s&eacute;curit&eacute; pendant le test.</p></li><li class="list__item" id="z3l84kq_145"><p id="z3l84kq_150">d) Pour importer le <code class="code" id="z3l84kq_151">MockMvc</code> bean.</p></li></ul></li><li class="list__item" id="z3l84kq_121"><p id="z3l84kq_152">(QCM) Un statut HTTP <code class="code" id="z3l84kq_154">403 Forbidden</code> signifie que :</p><ul class="list _bullet" id="z3l84kq_153"><li class="list__item" id="z3l84kq_155"><p id="z3l84kq_159">a) Le client n'est pas authentifi&eacute;.</p></li><li class="list__item" id="z3l84kq_156"><p id="z3l84kq_160">b) Le serveur a compris la requ&ecirc;te, mais refuse de l'autoriser car le client n'a pas les droits n&eacute;cessaires.</p></li><li class="list__item" id="z3l84kq_157"><p id="z3l84kq_161">c) La ressource demand&eacute;e n'existe pas.</p></li><li class="list__item" id="z3l84kq_158"><p id="z3l84kq_162">d) Il y a une erreur dans la requ&ecirc;te du client.</p></li></ul></li></ol><p id="z3l84kq_116"><span class="emphasis" id="z3l84kq_163">(Les corrections de l'auto-&eacute;valuation seront fournies &agrave; la toute fin du support de cours.)</span></p></section><section class="chapter"><h2 id="conclusion-de-la-partie" data-toc="conclusion-de-la-partie">Conclusion de la partie</h2><p id="z3l84kq_164">Vous avez ajout&eacute; une corde essentielle &agrave; votre arc de testeur : la capacit&eacute; de naviguer dans un environnement s&eacute;curis&eacute;. Vous savez d&eacute;sormais que tester la s&eacute;curit&eacute; n'est pas une magie noire. Gr&acirc;ce &agrave; l'arsenal fourni par <code class="code" id="z3l84kq_167">spring-security-test</code>, et notamment &agrave; l'annotation <code class="code" id="z3l84kq_168">@WithMockUser</code>, vous pouvez simuler n'importe quel type d' utilisateur et de r&ocirc;le pour v&eacute;rifier m&eacute;ticuleusement que vos r&egrave;gles d'autorisation sont bien appliqu&eacute;es.</p><p id="z3l84kq_165">Vous avez appris &agrave; tester les acc&egrave;s autoris&eacute;s, les acc&egrave;s refus&eacute;s pour cause de mauvais r&ocirc;le, et les acc&egrave;s refus&eacute;s pour absence d'authentification. C'est une comp&eacute;tence fondamentale pour construire des applications non seulement fonctionnelles, mais aussi robustes et s&ucirc;res.</p><p id="z3l84kq_166">Notre prochain chapitre s'attaquera &agrave; un autre aspect parfois d&eacute;licat : le test du code asynchrone et r&eacute;actif. Comment tester quelque chose qui ne se produit pas imm&eacute;diatement ? C'est ce que nous allons voir.</p></section><div class="last-modified">16 juin 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="008-00-testcontainers.html" class="navigation-links__prev">Chapitre 8 : Le Test en Conditions R&eacute;elles : G&eacute;rer les D&eacute;pendances Externes avec Testcontainers (L'essentiel)</a><a href="010-00-async-test.html" class="navigation-links__next">Chapitre 10 : Le Test dans une Autre Dimension : Code Asynchrone et R&eacute;actif (L'essentiel)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>